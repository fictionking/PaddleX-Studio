<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Hue Corrected Color Picker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- Tailwind 配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        neutral: '#64748B',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        inter: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    boxShadow: {
                        'elevation-1': '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
                        'elevation-2': '0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12)',
                    }
                },
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .color-transition {
                transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            }
            .transform-transition {
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }
            /* 色相渐变 - 从上到下按色相值递增排列 */
            .hue-gradient {
                background: linear-gradient(
                    to bottom,
                    #ff0000, #ffff00, #00ff00, 
                    #00ffff, #0000ff, #ff00ff, #ff0000
                );
            }
            /* 饱和度渐变 */
            .saturation-gradient {
                background: linear-gradient(to bottom, currentColor, #808080);
            }
            /* 亮度渐变 */
            .lightness-gradient {
                background: linear-gradient(to bottom, #ffffff, currentColor, #000000);
            }
            /* 垂直滑块样式 */
            input[type=range][orient=vertical] {
                writing-mode: bt-lr; /* IE */
                -webkit-appearance: slider-vertical; /* Chromium */
                width: 8px;
                height: 100%;
                padding: 0 5px;
            }
            /* 亮度环样式 */
            .lightness-ring {
                position: absolute;
                width: 100%;
                height: 100%;
                border-radius: 50%;
                pointer-events: auto;
            }
            /* 亮度环标记 - 调整大小与环的宽度匹配 */
            .ring-marker {
                position: absolute;
                width: 14px;
                height: 14px;
                border: 2px solid white;
                border-radius: 50%;
                transform: translate(-50%, -50%);
                box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3);
                pointer-events: none;
                z-index: 1;
            }
            /* 颜色圆盘标记 */
            .wheel-marker {
                width: 14px;
                height: 14px;
                border: 2px solid white;
                border-radius: 50%;
                box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
                transform: translate(-50%, -50%);
                pointer-events: none;
                z-index: 1;
            }
            /* 滑块长条标记 */
            .slider-bar-marker {
                width: 100%;
                height: 4px;
                left: 0;
                border-radius: 2px;
                border: 1px solid rgba(0,0,0,0.2);
                background-color: white;
                transform: translateY(-50%);
                pointer-events: none;
            }
        }
    </style>
</head>

<body class="font-inter bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <!-- 主容器 -->
    <div class="bg-gray-800 rounded-xl shadow-elevation-2 w-full max-w-md overflow-hidden transform-transition">
        <!-- 标题栏 -->
        <div class="px-4 py-3 border-b border-gray-700 flex justify-between items-center">
            <h1 class="text-sm font-semibold text-white">Color Picker</h1>
            <button id="close-btn" class="text-gray-400 hover:text-white color-transition text-xs">
                <i class="fa fa-times"></i>
            </button>
        </div>

        <!-- 主要颜色选择区域 -->
        <div class="px-4 py-3 flex flex-col md:flex-row gap-4">
            <!-- 颜色选择区域 - 亮度环和色盘叠放 -->
            <div class="flex-1 flex  items-center justify-center">
                <!-- 分段环弧容器 - 位于底层 -->
                <div id="lightness-ring-container"
                    class="absolute w-[220px] h-[220px] rounded-full overflow-hidden shadow-inner">
                    <!-- 分段环弧将通过JS生成 -->
                    <!-- 饱和度环弧标记 -->
                    <div id="saturation-marker" class="ring-marker absolute hidden"></div>
                    <!-- 亮度环弧标记 -->
                    <div id="lightness-marker" class="ring-marker absolute hidden"></div>
                    <!-- 透明度环弧标记 -->
                    <div id="alpha-marker" class="ring-marker absolute hidden"></div>
                </div>
                <!-- 彩色圆盘 - 位于上层 -->
                <div id="color-wheel" class="absolute w-[200px] h-[200px] rounded-full overflow-hidden shadow-inner">
                    <!-- 颜色圆盘将通过JS生成 -->
                    <!-- 颜色圆盘标记 -->
                    <div id="wheel-marker" class="wheel-marker absolute hidden"></div>

                </div>

            </div>

            <!-- 两个垂直滑块（移除了色相滑块） -->
            <div class="flex gap-2">

                <!-- 饱和度滑块 -->
                <div class="flex flex-col items-center w-6">
                    <label class="text-xs text-gray-300 mb-1.5 block text-center">Saturation</label>
                    <div class="relative h-[200px] rounded-lg overflow-hidden w-full">
                        <div class="absolute inset-0 saturation-gradient" id="saturation-gradient"></div>
                        <input type="range" id="saturation-slider" min="0" max="100" value="100" orient="vertical"
                            class="absolute inset-0 opacity-0 cursor-pointer">
                        <div id="saturation-marker" class="slider-bar-marker absolute" style="top: 0%"></div>
                    </div>
                    <span class="text-xs text-gray-300 mt-1" id="saturation-value">100%</span>
                </div>

                <!-- 亮度滑块 -->
                <div class="flex flex-col items-center w-6">
                    <label class="text-xs text-gray-300 mb-1.5 block text-center">Lightness</label>
                    <div class="relative h-[200px] rounded-lg overflow-hidden w-full">
                        <div class="absolute inset-0 lightness-gradient" id="lightness-gradient"></div>
                        <input type="range" id="lightness-slider" min="0" max="100" value="50" orient="vertical"
                            class="absolute inset-0 opacity-0 cursor-pointer">
                        <div id="lightness-marker" class="slider-bar-marker absolute" style="top: 50%"></div>
                    </div>
                    <span class="text-xs text-gray-300 mt-1" id="lightness-value">50%</span>
                </div>
            </div>
        </div>

        <!-- 颜色预览和输入区 -->
        <div class="px-4 pb-3">
            <div id="color-preview"
                class="w-full h-16 rounded-lg shadow-inner bg-primary relative overflow-hidden mb-3">
                <div class="absolute inset-0 bg-gradient-to-tr from-transparent to-white/20"></div>
            </div>

            <div class="grid grid-cols-3 gap-2 mb-4">
                <div class="relative">
                    <label class="text-xs text-gray-300 mb-1 block">HEX</label>
                    <div class="flex">
                        <input type="text" id="hex-input" value="#3B82F6"
                            class="w-full px-2 py-1.5 border border-gray-700 bg-gray-800 rounded-l-lg focus:outline-none focus:ring-1.5 focus:ring-primary/50 text-xs text-white" />
                        <button
                            class="copy-btn bg-gray-700 hover:bg-gray-600 px-2 rounded-r-lg color-transition text-xs"
                            data-target="hex-input">
                            <i class="fa fa-copy text-gray-300"></i>
                        </button>
                    </div>
                </div>
                <div class="relative">
                    <label class="text-xs text-gray-300 mb-1 block">RGB</label>
                    <div class="flex">
                        <input type="text" id="rgb-input" value="rgb(59, 130, 246)"
                            class="w-full px-2 py-1.5 border border-gray-700 bg-gray-800 rounded-l-lg focus:outline-none focus:ring-1.5 focus:ring-primary/50 text-xs text-white" />
                        <button
                            class="copy-btn bg-gray-700 hover:bg-gray-600 px-2 rounded-r-lg color-transition text-xs"
                            data-target="rgb-input">
                            <i class="fa fa-copy text-gray-300"></i>
                        </button>
                    </div>
                </div>
                <div class="relative">
                    <label class="text-xs text-gray-300 mb-1 block">HSL</label>
                    <div class="flex">
                        <input type="text" id="hsl-input" value="hsl(217, 90%, 58%)"
                            class="w-full px-2 py-1.5 border border-gray-700 bg-gray-800 rounded-l-lg focus:outline-none focus:ring-1.5 focus:ring-primary/50 text-xs text-white" />
                        <button
                            class="copy-btn bg-gray-700 hover:bg-gray-600 px-2 rounded-r-lg color-transition text-xs"
                            data-target="hsl-input">
                            <i class="fa fa-copy text-gray-300"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Alpha (透明度) 控制 -->
            <div>
                <div class="flex justify-between mb-1.5">
                    <label class="text-xs text-gray-300">Alpha</label>
                    <span class="text-xs text-gray-300" id="alpha-value">100%</span>
                </div>
                <div class="relative h-5 rounded-lg overflow-hidden">
                    <div id="alpha-slider-bg"
                        class="absolute inset-0 bg-gradient-to-r from-transparent via-primary to-primary"></div>
                    <input type="range" id="alpha-slider" min="0" max="100" value="100"
                        class="w-full h-full opacity-0 cursor-pointer">
                    <div id="alpha-marker" class="slider-bar-marker absolute h-5" style="top: 50%; left: 100%"></div>
                </div>
                <div class="flex justify-between text-xs text-gray-300">
                    <span>0%</span>
                    <span>50%</span>
                    <span>100%</span>
                </div>
            </div>
        </div>

        <!-- 最近使用的颜色 -->
        <div class="px-4 pb-4 border-t border-gray-700 pt-3">
            <h3 class="text-xs font-medium text-gray-300 mb-2">Recent</h3>
            <div id="recent-colors" class="flex flex-wrap gap-1.5">
                <div class="recent-color w-6 h-6 rounded-full cursor-pointer transform-transition hover:scale-110 border border-gray-700"
                    style="background-color: #EF4444"></div>
                <div class="recent-color w-6 h-6 rounded-full cursor-pointer transform-transition hover:scale-110 border border-gray-700"
                    style="background-color: #10B981"></div>
                <div class="recent-color w-6 h-6 rounded-full cursor-pointer transform-transition hover:scale-110 border border-gray-700"
                    style="background-color: #F59E0B"></div>
                <div class="recent-color w-6 h-6 rounded-full cursor-pointer transform-transition hover:scale-110 border border-gray-700"
                    style="background-color: #8B5CF6"></div>
                <div class="recent-color w-6 h-6 rounded-full cursor-pointer transform-transition hover:scale-110 border border-gray-700"
                    style="background-color: #EC4899"></div>
                <div class="recent-color w-6 h-6 rounded-full cursor-pointer transform-transition hover:scale-110 border border-gray-700"
                    style="background-color: #64748B"></div>
                <div
                    class="w-6 h-6 rounded-full border border-dashed border-gray-600 flex items-center justify-center text-gray-400 text-xs cursor-pointer hover:border-gray-400 color-transition">
                    <i class="fa fa-plus"></i>
                </div>
            </div>
        </div>
    </div>

    <!-- 复制成功提示 -->
    <div id="copy-toast"
        class="fixed top-4 right-4 bg-dark text-white px-3 py-1.5 rounded-lg shadow-elevation-2 opacity-0 transition-opacity duration-300 pointer-events-none text-xs">
        <span>Copied!</span>
    </div>

    <script>
        // 颜色转换工具函数
        const ColorUtils = {
            // HSL 转 RGB
            hslToRgb: (h, s, l) => {
                s /= 100;
                l /= 100;

                let r, g, b;

                if (s === 0) {
                    r = g = b = l; // 灰色
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;

                    r = hue2rgb(p, q, h / 360 + 1 / 3);
                    g = hue2rgb(p, q, h / 360);
                    b = hue2rgb(p, q, h / 360 - 1 / 3);
                }

                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            },

            // RGB 转 HEX
            rgbToHex: (r, g, b) => {
                return `#${[r, g, b]
                    .map(x => Math.round(x).toString(16).padStart(2, '0'))
                    .join('')
                    .toUpperCase()}`;
            },

            // RGB 转 HSL
            rgbToHsl: (r, g, b) => {
                r /= 255;
                g /= 255;
                b /= 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0; // 灰色
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }

                    h *= 60;
                }

                return {
                    h: Math.round(h),
                    s: Math.round(s * 100),
                    l: Math.round(l * 100)
                };
            },

            // HEX 转 RGB
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },

            // 从圆盘位置计算HSL颜色
            positionToHsl: (x, y, centerX, centerY, radius) => {
                const dx = x - centerX;
                const dy = centerY - y;
                const distance = Math.min(Math.sqrt(dx * dx + dy * dy), radius);
                // 修正色相角度计算，使圆盘与滑块保持一致
                const angle = (Math.atan2(-dy, dx) * 180 / Math.PI + 360) % 360;

                return {
                    h: angle,
                    s: (distance / radius) * 100,
                    l: 50
                };
            },

            // 从HSL计算圆盘位置
            hslToPosition: (h, s, centerX, centerY, radius) => {
                const radians = h * Math.PI / 180;
                const distance = (s / 100) * radius;

                // 修正Y轴方向，使圆盘与滑块保持一致
                return {
                    x: centerX + distance * Math.cos(radians),
                    y: centerY - distance * Math.sin(-radians)
                };
            }
        };

        // 创建亮度环 - 使用中心辐射渐变实现从纯白色到纯黑色的连续渐变效果，基于当前选中的颜色
        function createLightnessRing(element, baseColor = null) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = Math.min(element.clientWidth, element.clientHeight);
            const scale = 2;
            canvas.width = size * scale;
            canvas.height = size * scale;
            canvas.style.width = `${size}px`;
            canvas.style.height = `${size}px`;
            canvas.className = 'lightness-ring';
            canvas.style.zIndex = '0'; // 确保亮度环位于色盘下层

            // 只删除已经存在的canvas元素，保留其他元素如ring-marker
            const existingCanvases = element.querySelectorAll('canvas');
            existingCanvases.forEach(canvasEl => {
                element.removeChild(canvasEl);
            });
            element.appendChild(canvas);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const outerRadius = canvas.width / 2;
            const innerRadius = outerRadius * 0.87; // 环的宽度，设置为外半径的0.9倍，使内径大于色盘的外径

            // 如果没有提供基色，使用默认的蓝色
            if (!baseColor) {
                baseColor = { r: 59, g: 130, b: 246 }; // 默认蓝色
            }
            
            // 计算当前颜色的HSL值
            const hsl = ColorUtils.rgbToHsl(baseColor.r, baseColor.g, baseColor.b);
            

            // 定义三个分段环弧的起始角度和占用角度
            // 每个弧占用100度
            const segments = [
                { startAngle: 160, arcAngle: 100, type: 'saturation' },  // 160度到260度
                { startAngle: 280, arcAngle: 100, type: 'lightness' },   // -80度到20度（280度到380度，即280度到20度）
                { startAngle: 40, arcAngle: 100, type: 'alpha' }         // 40度到140度
            ];

            // 为每个分段绘制环弧
            segments.forEach(segment => {
                if (ctx.createConicGradient) {
                    // 使用圆锥渐变创建环弧
                    const gradient = ctx.createConicGradient(segment.startAngle * Math.PI / 180, centerX, centerY);
                    
                    // 根据环弧类型设置不同的渐变颜色
                    if (segment.type === 'saturation') {
                        // 饱和度环弧：从基于当前h值的基色（固定s=100%）到灰色的渐变
                        // 为饱和度弧创建基于当前h值的基色（固定s=100%，l=50%）
                        const saturationBaseColor = ColorUtils.hslToRgb(hsl.h, 100, 50);
                        gradient.addColorStop(0, `rgba(${saturationBaseColor.r}, ${saturationBaseColor.g}, ${saturationBaseColor.b}, 1)`);
                        gradient.addColorStop(segment.arcAngle / 360, 'rgba(128, 128, 128, 0.9)');
                    } else if (segment.type === 'lightness') {
                        // 亮度环弧：从白色到黑色的渐变
                        const lightnessBaseColor = ColorUtils.hslToRgb(hsl.h,hsl.s,50)
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                        gradient.addColorStop(segment.arcAngle / 720, `rgba(${lightnessBaseColor.r}, ${lightnessBaseColor.g}, ${lightnessBaseColor.b}, 1)`);
                        gradient.addColorStop(segment.arcAngle / 360, 'rgba(0, 0, 0, 0.9)');
                    } else if (segment.type === 'alpha') {
                        // 透明度环弧：从透明到基色的渐变
                        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                        gradient.addColorStop(segment.arcAngle / 360, `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 1)`);
                    }

                    // 绘制环弧
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, outerRadius, segment.startAngle * Math.PI / 180, (segment.startAngle + segment.arcAngle) * Math.PI / 180);
                    ctx.arc(centerX, centerY, innerRadius, (segment.startAngle + segment.arcAngle) * Math.PI / 180, segment.startAngle * Math.PI / 180, true);
                    ctx.closePath();
                    ctx.fillStyle = gradient;
                    ctx.fill();
                } 
            });

            return {
                canvas,
                centerX: centerX / scale,
                centerY: centerY / scale,
                outerRadius: outerRadius / scale,
                innerRadius: innerRadius / scale
            };
        }

        // 创建颜色圆盘
        function createColorWheel(element) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = Math.min(element.clientWidth, element.clientHeight);
            const scale = 2;
            canvas.width = size * scale;
            canvas.height = size * scale;
            canvas.style.width = `${size}px`;
            canvas.style.height = `${size}px`;
            element.appendChild(canvas);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 * 0.8; // 缩小色盘，为色相环留出空间

            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const pixels = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const dx = x - centerX;
                    const dy = centerY - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= radius) {
                        // 修正色相角度，使圆盘与滑块方向一致
                        const angle = (Math.atan2(-dy, dx) * 180 / Math.PI + 360) % 360;
                        const saturation = Math.min(100, (distance / radius) * 100);
                        const lightness = 50;

                        const rgb = ColorUtils.hslToRgb(angle, saturation, lightness);
                        const index = (y * canvas.width + x) * 4;
                        pixels[index] = rgb.r;
                        pixels[index + 1] = rgb.g;
                        pixels[index + 2] = rgb.b;
                        pixels[index + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.filter = 'blur(1px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';

            return {
                canvas,
                centerX: centerX / scale,
                centerY: centerY / scale,
                radius: radius / scale
            };
        }

        // 颜色选择器主逻辑
        document.addEventListener('DOMContentLoaded', () => {
            const colorWheel = document.getElementById('color-wheel');
            const wheelData = createColorWheel(colorWheel);
            const wheelMarker = document.getElementById('wheel-marker');

            // 初始化分段环弧
            const lightnessRingContainer = document.getElementById('lightness-ring-container');
            let ringData = null;

            // DOM 元素
            const hueValue = document.getElementById('hue-value');

            const saturationSlider = document.getElementById('saturation-slider');
            const saturationMarker = document.getElementById('saturation-marker');
            const saturationValue = document.getElementById('saturation-value');
            const saturationGradient = document.getElementById('saturation-gradient');

            const lightnessSlider = document.getElementById('lightness-slider');
            const lightnessMarker = document.getElementById('lightness-marker');
            const lightnessValue = document.getElementById('lightness-value');
            const lightnessGradient = document.getElementById('lightness-gradient');

            const alphaSlider = document.getElementById('alpha-slider');
            const alphaMarker = document.getElementById('alpha-marker');
            const alphaValue = document.getElementById('alpha-value');

            const colorPreview = document.getElementById('color-preview');
            const hexInput = document.getElementById('hex-input');
            const rgbInput = document.getElementById('rgb-input');
            const hslInput = document.getElementById('hsl-input');

            const copyBtns = document.querySelectorAll('.copy-btn');
            const copyToast = document.getElementById('copy-toast');
            const recentColors = document.querySelectorAll('.recent-color');

            // 当前颜色状态
            let currentColor = {
                h: 217,    // 色相
                s: 100,    // 饱和度
                l: 50,     // 亮度
                a: 100     // 透明度
            };

            // 存储上一次的色相和饱和度值，用于检测变化
            let lastHue = currentColor.h;
            let lastSaturation = currentColor.s;

            // 根据当前颜色创建亮度环 - 使用固定亮度值(50%)计算基色，确保亮度环基于色盘位置的颜色
            const createRingWithCurrentColor = () => {
                const { h, s } = currentColor;
                const fixedLightness = 50; // 固定亮度值为50%，忽略当前颜色的亮度值
                const rgb = ColorUtils.hslToRgb(h, s, fixedLightness);
                ringData = createLightnessRing(lightnessRingContainer, rgb);
            };

            // 初始化创建亮度环
            createRingWithCurrentColor();

            // 更新颜色显示
            const updateColorDisplay = () => {
                const { h, s, l, a } = currentColor;
                const rgb = ColorUtils.hslToRgb(h, s, l);
                const hex = ColorUtils.rgbToHex(rgb.r, rgb.g, rgb.b);

                colorPreview.style.backgroundColor = `hsla(${h}, ${s}%, ${l}%, ${a / 100})`;

                hexInput.value = hex;
                rgbInput.value = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                hslInput.value = `hsl(${h}, ${s}%, ${l}%)`;

                saturationValue.textContent = `${s}%`;
                lightnessValue.textContent = `${l}%`;
                alphaValue.textContent = `${a}%`;

                const hueColor = ColorUtils.hslToRgb(h, 100, 50);
                const hueHex = ColorUtils.rgbToHex(hueColor.r, hueColor.g, hueColor.b);

                saturationGradient.style.color = hueHex;
                lightnessGradient.style.color = hueHex;

                // 当色相或饱和度改变时，重新绘制亮度环
                if (Math.abs(h - lastHue) > 0.5 || Math.abs(s - lastSaturation) > 0.5) {
                    createRingWithCurrentColor();
                    lastHue = h;
                    lastSaturation = s;
                }

                updateMarkerPositions();
            };

            // 更新标记位置
            const updateMarkerPositions = () => {
                const { h, s, l, a } = currentColor;

                // 饱和度标记
                const saturationPercent = 100 - s;
                saturationMarker.style.top = `${saturationPercent}%`;

                // 亮度标记
                const lightnessPercent = 100 - l;
                lightnessMarker.style.top = `${lightnessPercent}%`;

                // 透明度标记
                const alphaPercent = a;
                alphaMarker.style.left = `${alphaPercent}%`;

                // 颜色圆盘标记
                const pos = ColorUtils.hslToPosition(
                    h, s,
                    wheelData.centerX, wheelData.centerY,
                    wheelData.radius
                );
                wheelMarker.style.left = `${pos.x}px`;
                wheelMarker.style.top = `${pos.y}px`;
                wheelMarker.style.display = 'block';
                const wheelRgb = ColorUtils.hslToRgb(h, s, 50); // 使用固定亮度值50%，与色盘一致
                wheelMarker.style.backgroundColor = `rgb(${wheelRgb.r}, ${wheelRgb.g}, ${wheelRgb.b})`;

                // 为每个分段环弧添加标记
                // 饱和度环弧标记 - 根据当前饱和度值计算角度位置
                const saturationAngle = 160 + (100 - s) * 100 / 100;
                const saturationDistanceFromCenter = (ringData.innerRadius + ringData.outerRadius) / 2;
                const saturationPosX = ringData.centerX + Math.cos(saturationAngle * Math.PI / 180) * saturationDistanceFromCenter;
                const saturationPosY = ringData.centerY + Math.sin(saturationAngle * Math.PI / 180) * saturationDistanceFromCenter;
                
                saturationMarker.style.left = `${saturationPosX}px`;
                saturationMarker.style.top = `${saturationPosY}px`;
                saturationMarker.style.display = 'block';
                
                // 亮度环弧标记 - 根据当前亮度值计算角度位置
                // 注意：因为亮度弧跨越了360度边界（280度到20度），需要特殊处理角度计算
                let lightnessAngle = 280 + (100 - l) * 100 / 100;
                if (lightnessAngle > 360) {
                    lightnessAngle -= 360;
                }
                const lightnessDistanceFromCenter = (ringData.innerRadius + ringData.outerRadius) / 2;
                const lightnessPosX = ringData.centerX + Math.cos(lightnessAngle * Math.PI / 180) * lightnessDistanceFromCenter;
                const lightnessPosY = ringData.centerY + Math.sin(lightnessAngle * Math.PI / 180) * lightnessDistanceFromCenter;
                
                lightnessMarker.style.left = `${lightnessPosX}px`;
                lightnessMarker.style.top = `${lightnessPosY}px`;
                lightnessMarker.style.display = 'block';
                
                // 透明度环弧标记 - 根据当前透明度值计算角度位置
                const alphaAngle = 40 + a * 100 / 100;
                const alphaDistanceFromCenter = (ringData.innerRadius + ringData.outerRadius) / 2;
                const alphaPosX = ringData.centerX + Math.cos(alphaAngle * Math.PI / 180) * alphaDistanceFromCenter;
                const alphaPosY = ringData.centerY + Math.sin(alphaAngle * Math.PI / 180) * alphaDistanceFromCenter;
                
                alphaMarker.style.left = `${alphaPosX}px`;
                alphaMarker.style.top = `${alphaPosY}px`;
                alphaMarker.style.display = 'block';
                
                // 为所有标记设置当前最终输出颜色
                const rgb = ColorUtils.hslToRgb(h, s, l);
                saturationMarker.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                lightnessMarker.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                alphaMarker.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            }

            // 处理颜色圆盘交互
            let isDraggingWheel = false;
            let isDraggingRing = false;

            const handleWheelInteraction = (clientX, clientY) => {
                const rect = wheelData.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                const hsl = ColorUtils.positionToHsl(
                    x, y,
                    wheelData.centerX, wheelData.centerY,
                    wheelData.radius
                );

                currentColor.h = Math.round(hsl.h);
                currentColor.s = Math.round(hsl.s);

                saturationSlider.value = currentColor.s;

                updateColorDisplay();
            };

            // 从亮度环位置计算亮度值 - 根据角度确定亮度值，连续渐变
            const getLightnessFromRingPosition = (clientX, clientY) => {
                const rect = ringData.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                const dx = x - ringData.centerX;
                const dy = y - ringData.centerY;
                // 计算角度（0-360度）
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                if (angle < 0) angle += 360;

                // 根据角度确定亮度值，连续渐变（0%到100%）
                const lightness = 100 - (angle / 360) * 100; // 亮度从100%到0%的连续变化

                // 限制在0-100范围内并四舍五入到整数
                return Math.round(Math.max(0, Math.min(100, lightness)));
            }

            // 处理亮度环交互
            const handleRingInteraction = (clientX, clientY) => {
                const lightness = getLightnessFromRingPosition(clientX, clientY);
                if (lightness !== null) {
                    currentColor.l = lightness;
                    updateColorDisplay();
                }
            };

            // 从色盘位置检测是否在色彩区域内
            const isPositionInColorWheel = (clientX, clientY) => {
                const rect = wheelData.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                const dx = x - wheelData.centerX;
                const dy = y - wheelData.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 检查是否在色盘半径范围内
                return distance <= wheelData.radius * 1.1; // 添加一些容差范围
            }

            colorWheel.addEventListener('mousedown', (e) => {
                // 只有当鼠标按下位置在色盘色彩区域内时，才触发交互
                if (isPositionInColorWheel(e.clientX, e.clientY)) {
                    isDraggingWheel = true;
                    handleWheelInteraction(e.clientX, e.clientY);
                }
            });

            // 鼠标移动事件，同时处理色盘和分段环弧
            document.addEventListener('mousemove', (e) => {
                if (isDraggingWheel) {
                    handleWheelInteraction(e.clientX, e.clientY);
                } else if (isDraggingRing && currentDraggingSegmentType) {
                    const rect = ringData.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // 根据鼠标按下时确定的环弧类型和当前角度计算值
                    const value = getValueFromSegmentPosition(x, y, currentDraggingSegmentType);
                    if (value !== null) {
                        if (currentDraggingSegmentType === 'saturation') {
                            currentColor.s = value;
                        } else if (currentDraggingSegmentType === 'lightness') {
                            currentColor.l = value;
                        } else if (currentDraggingSegmentType === 'alpha') {
                            currentColor.a = value;
                        }
                        updateColorDisplay();
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingWheel = false;
                isDraggingRing = false;
                currentDraggingSegmentType = null;
            });

            // 触摸设备支持 - 色盘
            colorWheel.addEventListener('touchstart', (e) => {
                isDraggingWheel = true;
                const touch = e.touches[0];
                handleWheelInteraction(touch.clientX, touch.clientY);
                e.preventDefault();
            });
            
            // 触摸设备支持 - 环弧
            document.addEventListener('touchstart', (e) => {
                // 只有当不是在拖动色盘时，才触发环弧的交互
                if (!isDraggingWheel) {
                    const touch = e.touches[0];
                    const rect = ringData.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // 检查点击位置属于哪个环弧
                    const segmentType = getSegmentTypeAtPosition(x, y);
                    
                    if (segmentType) {
                        isDraggingRing = true;
                        currentDraggingSegmentType = segmentType;
                        e.preventDefault();
                    }
                }
            });

            // 触摸移动事件，同时处理色盘和分段环弧
            document.addEventListener('touchmove', (e) => {
                if (isDraggingWheel) {
                    const touch = e.touches[0];
                    handleWheelInteraction(touch.clientX, touch.clientY);
                    e.preventDefault();
                } else if (isDraggingRing && currentDraggingSegmentType) {
                    const touch = e.touches[0];
                    const rect = ringData.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // 根据触摸按下时确定的环弧类型和当前角度计算值
                    const value = getValueFromSegmentPosition(x, y, currentDraggingSegmentType);
                    if (value !== null) {
                        if (currentDraggingSegmentType === 'saturation') {
                            currentColor.s = value;
                        } else if (currentDraggingSegmentType === 'lightness') {
                            currentColor.l = value;
                        } else if (currentDraggingSegmentType === 'alpha') {
                            currentColor.a = value;
                        }
                        updateColorDisplay();
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('touchend', () => {
                isDraggingWheel = false;
                isDraggingRing = false;
                currentDraggingSegmentType = null;
            });

            // 定义三个分段环弧的起始角度和占用角度
            const segments = [
                { startAngle: 160, arcAngle: 100, type: 'saturation' },  // 160度到260度
                { startAngle: 280, arcAngle: 100, type: 'lightness' },   // -80度到20度（280度到380度，即280度到20度）
                { startAngle: 40, arcAngle: 100, type: 'alpha' }         // 40度到140度
            ];

            // 检查点击位置是否在某个环弧上，并返回对应的环弧类型
            const getSegmentTypeAtPosition = (x, y) => {
                const centerX = ringData.centerX;
                const centerY = ringData.centerY;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 检查是否在环的宽度范围内
                if (distance < ringData.innerRadius * 0.9 || distance > ringData.outerRadius * 1.1) {
                    return null;
                }
                
                // 计算点击位置的角度
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                if (angle < 0) angle += 360;
                
                // 检查点击位置属于哪个环弧
                for (const segment of segments) {
                    const endAngle = segment.startAngle + segment.arcAngle;
                    
                    // 处理跨越360度边界的情况
                    if (endAngle > 360) {
                        // 对于跨越360度边界的环弧（如亮度弧：280度到380度即280度到20度）
                        if ((angle >= segment.startAngle && angle <= 360) || (angle >= 0 && angle <= endAngle - 360)) {
                            return segment.type;
                        }
                    } else {
                        // 普通环弧（不跨越360度边界）
                        if (angle >= segment.startAngle && angle <= endAngle) {
                            return segment.type;
                        }
                    }
                }
                
                return null;
            };

            // 从环弧位置计算对应的值
            const getValueFromSegmentPosition = (x, y, segmentType) => {
                const centerX = ringData.centerX;
                const centerY = ringData.centerY;
                const dx = x - centerX;
                const dy = y - centerY;
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                if (angle < 0) angle += 360;
                
                // 根据不同的环弧类型计算值
                for (const segment of segments) {
                    if (segment.type === segmentType) {
                        // 计算在当前环弧中的相对位置
                        let relativePosition;
                        const endAngle = segment.startAngle + segment.arcAngle;
                        
                        // 处理跨越360度边界的情况
                        if (endAngle > 360) {
                            if (angle >= segment.startAngle) {
                                // 角度在起始角度到360度之间
                                relativePosition = (angle - segment.startAngle) / segment.arcAngle;
                                console.log('角度在起始角度到360度之间', relativePosition)
                            } else {
                                // 角度在0度到结束角度减去360度之间
                                if (angle < segment.startAngle && angle<=180) {
                                    angle += 360;
                                }
                                relativePosition = (angle - segment.startAngle) / segment.arcAngle;
                                console.log('角度在0度到结束角度减去360度之间', relativePosition)
                            }
                        } else {
                            // 普通环弧（不跨越360度边界）
                            relativePosition = (angle - segment.startAngle) / segment.arcAngle;
                        }
                        // 确保相对位置在0-1范围内
                        const clampedPosition = Math.max(0, Math.min(1, relativePosition));
                        
                        // 根据环弧类型返回不同的值
                        if (segmentType === 'saturation') {
                            return Math.round((1 - clampedPosition) * 100); // 饱和度从100%到0%
                        } else if (segmentType === 'lightness') {
                            return Math.round((1 - clampedPosition) * 100); // 亮度从100%到0%
                        } else if (segmentType === 'alpha') {
                            return Math.round(clampedPosition * 100); // 透明度从0%到100%
                        }
                    }
                }
                
                return null;
            };

            // 保存当前拖动的环弧类型
            let currentDraggingSegmentType = null;
            
            // 分段环弧鼠标事件
            document.addEventListener('mousedown', (e) => {
                // 只有当不是在拖动色盘时，才触发环弧的交互
                if (!isDraggingWheel) {
                    const rect = ringData.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // 检查点击位置属于哪个环弧
                    const segmentType = getSegmentTypeAtPosition(x, y);
                    
                    if (segmentType) {
                        isDraggingRing = true;
                        currentDraggingSegmentType = segmentType;
                        
                        // 根据点击的环弧类型处理交互
                        const value = getValueFromSegmentPosition(x, y, segmentType);
                        if (value !== null) {
                            if (segmentType === 'saturation') {
                                currentColor.s = value;
                            } else if (segmentType === 'lightness') {
                                currentColor.l = value;
                            } else if (segmentType === 'alpha') {
                                currentColor.a = value;
                            }
                            updateColorDisplay();
                        }
                        
                        e.stopPropagation(); // 阻止事件冒泡到色盘
                    }
                }
            });

            // 分段环弧触摸事件
            document.addEventListener('touchstart', (e) => {
                if (!isDraggingWheel) {
                    const touch = e.touches[0];
                    const rect = ringData.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // 检查触摸位置属于哪个环弧
                    const segmentType = getSegmentTypeAtPosition(x, y);
                    
                    if (segmentType) {
                        isDraggingRing = true;
                        
                        // 根据触摸的环弧类型处理交互
                        const value = getValueFromSegmentPosition(x, y, segmentType);
                        if (value !== null) {
                            if (segmentType === 'saturation') {
                                currentColor.s = value;
                            } else if (segmentType === 'lightness') {
                                currentColor.l = value;
                            } else if (segmentType === 'alpha') {
                                currentColor.a = value;
                            }
                            updateColorDisplay();
                        }
                        
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            });

            // 饱和度滑块事件
            saturationSlider.addEventListener('input', (e) => {
                currentColor.s = parseInt(e.target.value);
                updateColorDisplay();
            });

            // 亮度滑块事件
            lightnessSlider.addEventListener('input', (e) => {
                currentColor.l = parseInt(e.target.value);
                updateColorDisplay();
            });

            // 透明度滑块事件
            alphaSlider.addEventListener('input', (e) => {
                currentColor.a = parseInt(e.target.value);
                updateColorDisplay();
            });

            // 输入框事件处理
            hexInput.addEventListener('blur', (e) => {
                const rgb = ColorUtils.hexToRgb(e.target.value);
                if (rgb) {
                    const hsl = ColorUtils.rgbToHsl(rgb.r, rgb.g, rgb.b);
                    currentColor.h = hsl.h;
                    currentColor.s = hsl.s;
                    currentColor.l = hsl.l;

                    saturationSlider.value = hsl.s;
                    lightnessSlider.value = hsl.l;

                    updateColorDisplay();
                } else {
                    updateColorDisplay();
                }
            });

            rgbInput.addEventListener('blur', (e) => {
                const match = e.target.value.match(/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
                if (match) {
                    const r = parseInt(match[1]);
                    const g = parseInt(match[2]);
                    const b = parseInt(match[3]);

                    if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                        const hsl = ColorUtils.rgbToHsl(r, g, b);
                        currentColor.h = hsl.h;
                        currentColor.s = hsl.s;
                        currentColor.l = hsl.l;

                        saturationSlider.value = hsl.s;
                        lightnessSlider.value = hsl.l;

                        updateColorDisplay();
                        return;
                    }
                }
                updateColorDisplay();
            });

            hslInput.addEventListener('blur', (e) => {
                const match = e.target.value.match(/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)$/);
                if (match) {
                    const h = parseInt(match[1]);
                    const s = parseInt(match[2]);
                    const l = parseInt(match[3]);

                    if (h >= 0 && h <= 360 && s >= 0 && s <= 100 && l >= 0 && l <= 100) {
                        currentColor.h = h;
                        currentColor.s = s;
                        currentColor.l = l;

                        saturationSlider.value = s;
                        lightnessSlider.value = l;

                        updateColorDisplay();
                        return;
                    }
                }
                updateColorDisplay();
            });

            // 复制按钮功能
            copyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetId = btn.getAttribute('data-target');
                    const targetInput = document.getElementById(targetId);

                    targetInput.select();
                    document.execCommand('copy');

                    copyToast.style.opacity = '1';
                    setTimeout(() => {
                        copyToast.style.opacity = '0';
                    }, 2000);
                });
            });

            // 最近使用的颜色点击事件
            recentColors.forEach(colorEl => {
                colorEl.addEventListener('click', () => {
                    const color = colorEl.style.backgroundColor;
                    if (color) {
                        const match = color.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
                        if (match) {
                            const r = parseInt(match[1]);
                            const g = parseInt(match[2]);
                            const b = parseInt(match[3]);

                            const hsl = ColorUtils.rgbToHsl(r, g, b);
                            currentColor.h = hsl.h;
                            currentColor.s = hsl.s;
                            currentColor.l = hsl.l;

                            saturationSlider.value = hsl.s;
                            lightnessSlider.value = hsl.l;

                            updateColorDisplay();
                        }
                    }
                });
            });

            // 初始化
            updateColorDisplay();
        });
    </script>
</body>

</html>